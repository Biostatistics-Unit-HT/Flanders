#!/usr/bin/env nextflow

// Computational environments
profiles {
    ht_cluster {
        workDir = "/scratch/$USER/nf-figaro-work"
        cleanup = true
        process.queue = 'cpuq'
//        process.containerOptions = '-B /localscratch --cleanenv'
        executor {
            name = 'slurm'
            queueSize = 350
            pollInterval = '5s' // Determines how often to check for process termination
        }
//        singularity.cacheDir = '/ssu/gassu/singularity/'
        conda.enabled = true
        process {
            conda = "/ssu/bsssu/conda_envs_bsssu/coloc_pipe_env_v2" 
        }
//        conda.cacheDir = "/ssu/bsssu/conda_envs_bsssu/"
    }
}



// https://training.nextflow.io/basic_training/debugging/#dynamic-resources-allocation
process {

// memory errors which should be retried. otherwise error out
    errorStrategy = { task.exitStatus in [140,143,137] ? 'retry' : 'finish' }
    maxRetries = 3

    withName: 'MUNG_AND_LOCUS_BREAKER' {
        cpus   = 1
        memory = { task.attempt == 1 ? "24GB" : (task.attempt == 2 ? "48GB" : "92GB") }
        time = { task.attempt == 1 ? "1.h" : (task.attempt == 2 ? "2.h" : "4.h") }
    }

    withName: 'LOCUS_BREAKER' {
        cpus   = 1
        memory = { task.attempt == 1 ? "12GB" : (task.attempt == 2 ? "24GB" : "62GB") }
        time = { task.attempt == 1 ? "30.m" : (task.attempt == 2 ? "1.h" : "2.h") }
    }
    
    withName: 'COJO_AND_FINEMAPPING' {
        cpus = 1
        memory = { task.attempt == 1 ? "24GB" : (task.attempt == 2 ? "48GB" : "92GB") }
        time = { task.attempt == 1 ? "45.m" : (task.attempt == 2 ? "5.h" : "15.h") }
    }
    
    withName: 'SUSIE_FINEMAPPING' {
        cpus = 1
        memory = { task.attempt == 1 ? "24GB" : (task.attempt == 2 ? "48GB" : "92GB") }
        time = { task.attempt == 1 ? "45.m" : (task.attempt == 2 ? "10.h" : "30.h") }
    }

    withLabel: 'appending_tables' {
        cpus   = 1
        memory = { task.attempt == 1 ? "8GB" : (task.attempt == 2 ? "16GB" : "24GB") }
        time = { task.attempt == 1 ? "15.m" : (task.attempt == 2 ? "30.m" : "1.h") }
    }

    withName: 'FIND_CS_OVERLAP_BY_CHR' {
        cpus   = 1
        memory = { task.attempt == 1 ? "32GB" : (task.attempt == 2 ? "64GB" : "92GB") }
        time = { task.attempt == 1 ? "1.h" : (task.attempt == 2 ? "2.h" : "4.h") }
    }

    withName: 'COLOC' {
        cpus   = 1
        memory = { task.attempt == 1 ? "24GB" : (task.attempt == 2 ? "48GB" : "64GB") }
        time = { task.attempt == 1 ? "1.h" : (task.attempt == 2 ? "4.h" : "8.h") }
    }
    
}


// Function to ensure that resource requirements don't go beyond a maximum limit
// Implemented with `resourceLimits` in v.24.04.0. "The resourceLimits directive allows you to specify
// environment-specific limits for task resource requests. Resource limits can be specified in the configuration
// process { resourceLimits = [ cpus: 24, memory: 768.GB, time: 72.h ] }"

def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}
